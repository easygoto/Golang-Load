# 基本语法

## 数据类型

```go
package main

import (
    "fmt"
)

type Model interface {
    getId() int
}

type Admin struct {
    id int
}

func (admin Admin) getId() int {
    return admin.id
}

type User struct {
    id      int
    name    string
    isAdmin bool
}

func (user User) getId() int {
    return user.id
}

func main() {
    var ui uint = 0xffffffffffffffff
    var i, f, c, s, cx = 99999999, 3.099128981278123123, '和', "Welcome", 12 + 3i
    var pui, pf, pcx, ps = &ui, &f, &cx, &s
    fmt.Printf("%-24T: %t\n", false, false)
    fmt.Printf("%-24T: %d, %o, %x, %X\n", i, i, i, i, i)
    fmt.Printf("%-24T: %d, %X\n", ui, ui, ui)
    fmt.Printf("%-24T: %.6f\n", f, f)
    fmt.Printf("%-24T: %f\n", cx, cx)
    fmt.Printf("%-24T: %c(%d)\n", c, c, c)
    fmt.Printf("%-24T: %s\n", s, s)
    fmt.Printf("%-24T: %p = %d\n", pui, pui, *pui)
    fmt.Printf("%-24T: %p = %f\n", pf, pf, *pf)
    fmt.Printf("%-24T: %p = %f\n", pcx, pcx, *pcx)
    fmt.Printf("%-24T: %p = %s\n", ps, ps, *ps)
    fmt.Println()

    arr := [...]User{{11, "root", true}, {12, "test", false}, {21, "user", false}}
    mp := map[string]string{"a": "apple", "b": "banana", "d": "dog"}
    st := struct{ id int }{1}
    user := User{id: 1, name: "admin", isAdmin: true}
    mod := Admin{56}
    ch := make(chan User)
    fn := func(msg string) string { return "msg: " + msg }
    fmt.Printf("%-24T: %v\n", arr, arr)
    fmt.Printf("%-24T: %v\n", mp, mp)
    fmt.Printf("%-24T: %v, len=%d\n", s[1:5], s[1:5], len(s[1:5]))
    fmt.Printf("%-24T: %v, len=%d, cap=%d\n", arr[1:], arr[1:], len(arr[1:]), cap(arr[1:]))
    fmt.Printf("%-24T: %#v\n", st, st)
    fmt.Printf("%-24T: %+v\n", user, user)
    fmt.Printf("%-24T: %+v, id: %d\n", mod, mod, mod.getId())
    fmt.Printf("%-24T: %#v\n", ch, ch)
    fmt.Printf("%-24T: %#v, %s\n", fn, &fn, fn("hello"))
}
```

### Printf

- %v: 自然形式内容
- %+v: 自然形式 json
- %#v: 自然形式 id 和 json
- %T: 类型
- %t: 布尔值
- %b: 二进制
- %o: 八进制
- %d: 十进制整型
- %x: 十六进制
- %X: 大写的十六进制
- %x: base64 编码
- %f: 浮点数, 复数
- %g: 精确浮点数, 复数
- %e: 科学计数法
- %E: 科学计数法
- %c: unicode 字符
- %s: 字符串
- %U: unicode 字符串
- %q: 带有引号
- %p: 指针值

## 特性

- 创建
    - make: 返回引用类型
    - new: 返回指针类型
- 基础方法
    - append: `切片`添加, 扩容
    - copy: `切片`拷贝
    - delete: 删除 map 中元素
    - close: 关闭 chan, 禁止写入
    - len: 实际长度, 支持 string, array, slice, map, chan
    - cap: 容器容量, 支持 array, slice, chan
- 异常处理
    - panic: 中断程序, 抛出信息
    - recover: 接收抛出的信息
    - defer: 关键字, 最后一定要做的事情
- 指针
    - 基本: 不支持指针++, --, 指向指针的指针和 C 语言一致, 没有函数指针
    - 指针数组: 一个数组里全是指针
    - 数组指针: 指向数组的指针
- json
    - Marshal: 序列化, 结构体中只会序列公用的字段, 结构体可以指定字段的映射
    - Unmarshal: 反序列化, 需要传递反序列化的原型

```go
package test

import (
	"encoding/json"
	"fmt"
	"testing"
)

type User struct {
	Id    int     `json:"id"`
	Money float64 `json:"money"`
}

func TestJson(t *testing.T) {
	jsonStr, err := json.Marshal(User{1, 3.14})
	if err != nil {
		panic(err)
	}
	_, _ = fmt.Println(string(jsonStr))

	u1 := User{}
	u2 := new(User)
	err1 := json.Unmarshal(jsonStr, &u1)
	err2 := json.Unmarshal(jsonStr, u2)
	if err1 != nil || err2 != nil {
		panic(err)
	}
	_, _ = fmt.Println(u1, u2)
}

func TestPoint(t *testing.T) {
	var ui uint = 123
	pUi := &ui
	ppUi := &pUi
	_, _ = fmt.Println(ui, &ui, *pUi, pUi, &pUi, **ppUi, *ppUi, ppUi)

	// 数组的指针
	var arr = [...]int{1, 2, 3}
	pArr := &arr
	_, _ = fmt.Println(pArr, (*pArr)[0], (*pArr)[1], (*pArr)[2])

	// 指针的数组
	a, b, c := 1, 2, 3
	pBrr := [...]*int{&a, &b, &c}
	_, _ = fmt.Println(pBrr, *pBrr[0], *pBrr[1], *pBrr[2])
}

func TestBasicFn(t *testing.T) {
	list := make([]string, 2)
	list[0] = "root"
	list[1] = "admin"
	_, _ = fmt.Printf("len=%d,cap=%d,value=%v,addr=%p\n", len(list), cap(list), list, &list)

	list = append(list, "user", "test")
	_, _ = fmt.Printf("len=%d,cap=%d,value=%v,addr=%p\n", len(list), cap(list), list, &list)

	listCp := make([]string, 2)
	copy(listCp, list)
	_, _ = fmt.Printf("len=%d,cap=%d,value=%v,addr=%p\n", len(listCp), cap(listCp), listCp, &listCp)
}

func TestExcept(t *testing.T) {
	defer func() {
		msg := recover()
		_, _ = fmt.Println("======== debug ========:", msg)
	}()
	panic("异常")
}

func TestNew(t *testing.T) {
	user := new(User)
	userCh := new(chan User)
	userMap := new(map[string]*User)

	user.Id = 1
	user.Money = 3.1415926535897932354626

	go func() {
		*userCh <- User{3, 3.1415926}
		*userCh <- User{4, 2.71828}
		close(*userCh)
	}()

	*userMap = map[string]*User{} // 需要初始化
	(*userMap)["root"] = &User{0, 1.7e308}
	(*userMap)["admin"] = &User{11, 3.4e38}
	delete(*userMap, "admin") // 删除元素

	_, _ = fmt.Println(user, userCh, userMap)
}

func TestMake(t *testing.T) {
	userSlice := make([]User, 2)
	userCh := make(chan User)
	userMap := make(map[string]User)

	userSlice[0] = User{1, 0.618}
	//userSlice[2] = User{2, 1.41421} // 数组越界

	go func() {
		userCh <- User{3, 3.1415926}
		userCh <- User{4, 2.71828}
		close(userCh)
	}()

	userMap["root"] = User{0, 1.7e308}
	userMap["admin"] = User{11, 3.4e38}

	_, _ = fmt.Println(userSlice, userCh, userMap)
}
```

## 并发

> 并发很简单, 只需要在函数之前加入关键字 `go` 即可
>
>> `func(c chan int) { // 读写均可的 channel }`
>>
>> `func(c <-chan int) { // 只读的 channel }`
>>
>> `func(c chan<- int) { // 只写的 channel }`
>
> 对外提供方法时, 涉及到 goroutine, 并且执行大量的通道操作, 程序结束时需要关闭通道

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    go HttpServer()
    ch := make(chan string)
    for i := 0; i < 5000; i++ {
        go PrintMessage(i, ch)
    }

    for {
        msg := <-ch
        fmt.Println(msg)
    }
}

func PrintMessage(id int, ch chan string) {
    ch <- fmt.Sprintf("the message from %d", id)
}

func HttpServer() {
    http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
        _, _ = fmt.Fprintf(writer, "<h1>Welcome! %s!</h1>", request.FormValue("name"))
    })
    _ = http.ListenAndServe(":8888", nil)
}
```

## 面向对象

1. `静态` 文件中函数外部定义的变量, 类似于静态变量
1. `封装` type struct 可以作为类使用 `type Apple struct {}`
1. `多态` type interface 作为接口, 类不需要声明直接实现方法, 实现方法后就是该接口的子类
1. `构造` 构造方法需要对外提供若干函数, 来实现构造函数的功能 `func (apple Apple) NewApple() *Apple {return &Apple{}}`
1. `继承` 可以把要继承的结构体作为一个成员变量`组合`到结构体中, 成员变量默认访问自己的, 没有就访问 `父类` 的
1. 接口定义在任何地方都没有问题, 始终会被继承, 优先使用本包的接口
1. 对外提供的方法和结构体名称和文件名没有任何关系, 和包名, 结构体名, 函数名有直接关系

> 测试文件

```go
package Demo

import (
	"fmt"
	"testing"

	"Box"
	. "Demo"
)

func TestDemo(t *testing.T) {
	_, _ = fmt.Println(new(Apple).Test())
	_, _ = fmt.Println(new(Bee).Test())
	_, _ = fmt.Println(new(Book).Test())
	_, _ = fmt.Println(new(Book).Demo())
	_, _ = fmt.Println(new(Box.Car).Test())
	_, _ = fmt.Println(new(Box.Cat).Test())

	_, _ = fmt.Println(Bee{Id: 123123}.SetIndex(10).GetIndex())
	_, _ = fmt.Println(new(Bee).GetIndex())
	_, _ = fmt.Println(new(Box.Car).GetIndex())
}
```

> 三个源文件

```go
package Demo

type Thing interface {
	Test() string
}

type Some interface {
	Demo() string
}

type Apple struct {
	Food
	weight float32
}

type Food struct {
	name string
}

func (apple Apple) Test() string {
    return "apple"
}
```

```go
package Demo

var index = 0

type Bee struct {
	Id int
}

func Bee_(id int) *Bee {
	return &Bee{Id: id}
}

func BeeId(id int) *Bee {
	return &Bee{Id: id}
}

func (Bee) Test() string {
	return "bee"
}

func (bee Bee) SetIndex(in int) *Bee {
	index = in
	return &bee
}

func (Bee) GetIndex() int {
	return index
}

type Book struct {
}

func (Book) Test() string {
	return "book"
}

func (Book) Demo() string {
	return "book demo ..."
}
```

```go
package Box

var index = 0

type Car struct {
}

func (Car) Test() string {
	return "car"
}

func (Car) GetIndex() int {
	return index
}

type Cat struct {
}

func (Cat) Test() string {
	return "cat"
}
```
