# 基本语法

## 数据类型

```go
package main

import (
    "fmt"
)

type Model interface {
    getId() int
}

type Admin struct {
    id int
}

func (admin Admin) getId() int {
    return admin.id
}

type User struct {
    id      int
    name    string
    isAdmin bool
}

func (user User) getId() int {
    return user.id
}

func main() {
    var ui uint = 0xffffffffffffffff
    var i, f, c, s, cx = 99999999, 3.099128981278123123, '和', "Welcome", 12 + 3i
    var pui, pf, pcx, ps = &ui, &f, &cx, &s
    fmt.Printf("%-24T: %t\n", false, false)
    fmt.Printf("%-24T: %d, %o, %x, %X\n", i, i, i, i, i)
    fmt.Printf("%-24T: %d, %X\n", ui, ui, ui)
    fmt.Printf("%-24T: %.6f\n", f, f)
    fmt.Printf("%-24T: %f\n", cx, cx)
    fmt.Printf("%-24T: %c(%d)\n", c, c, c)
    fmt.Printf("%-24T: %s\n", s, s)
    fmt.Printf("%-24T: %p = %d\n", pui, pui, *pui)
    fmt.Printf("%-24T: %p = %f\n", pf, pf, *pf)
    fmt.Printf("%-24T: %p = %f\n", pcx, pcx, *pcx)
    fmt.Printf("%-24T: %p = %s\n", ps, ps, *ps)
    fmt.Println()

    arr := [...]User{{11, "root", true}, {12, "test", false}, {21, "user", false}}
    mp := map[string]string{"a": "apple", "b": "banana", "d": "dog"}
    st := struct{ id int }{1}
    user := User{id: 1, name: "admin", isAdmin: true}
    mod := Admin{56}
    ch := make(chan User)
    fn := func(msg string) string { return "msg: " + msg }
    fmt.Printf("%-24T: %v\n", arr, arr)
    fmt.Printf("%-24T: %v\n", mp, mp)
    fmt.Printf("%-24T: %v, len=%d\n", s[1:5], s[1:5], len(s[1:5]))
    fmt.Printf("%-24T: %v, len=%d, cap=%d\n", arr[1:], arr[1:], len(arr[1:]), cap(arr[1:]))
    fmt.Printf("%-24T: %#v\n", st, st)
    fmt.Printf("%-24T: %+v\n", user, user)
    fmt.Printf("%-24T: %+v, id: %d\n", mod, mod, mod.getId())
    fmt.Printf("%-24T: %#v\n", ch, ch)
    fmt.Printf("%-24T: %#v, %s\n", fn, &fn, fn("hello"))
}
```

### Printf

- %v: 自然形式内容
- %+v: 自然形式 json
- %#v: 自然形式 id 和 json
- %T: 类型
- %t: 布尔值
- %b: 二进制
- %o: 八进制
- %d: 十进制整型
- %x: 十六进制
- %X: 大写的十六进制
- %x: base64 编码
- %f: 浮点数, 复数
- %g: 精确浮点数, 复数
- %e: 科学计数法
- %E: 科学计数法
- %c: unicode 字符
- %s: 字符串
- %U: unicode 字符串
- %q: 带有引号
- %p: 指针值

## 并发

> 并发很简单, 只需要在函数之前加入关键字 `go` 即可
>
>> `func(c chan int) { // 读写均可的 channel }`
>>
>> `func(c <-chan int) { // 只读的 channel }`
>>
>> `func(c chan<- int) { // 只写的 channel }`
>
> 对外提供方法时, 涉及到 goroutine, 并且执行大量的通道操作, 程序结束时需要关闭通道

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    go HttpServer()
    ch := make(chan string)
    for i := 0; i < 5000; i++ {
        go PrintMessage(i, ch)
    }

    for {
        msg := <-ch
        fmt.Println(msg)
    }
}

func PrintMessage(id int, ch chan string) {
    ch <- fmt.Sprintf("the message from %d", id)
}

func HttpServer() {
    http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
        _, _ = fmt.Fprintf(writer, "<h1>Welcome! %s!</h1>", request.FormValue("name"))
    })
    _ = http.ListenAndServe(":8888", nil)
}
```

## 面向对象

1. `静态` 文件中函数外部定义的变量, 类似于静态变量
1. `封装` type struct 可以作为类使用 `type Apple struct {}`
1. `多态` type interface 作为接口, 类不需要声明直接实现方法, 实现方法后就是该接口的子类
1. `构造` 构造方法需要对外提供若干函数, 来实现构造函数的功能 `func (apple Apple) NewApple() *Apple {return &Apple{}}`
1. `继承` 可以把要继承的结构体作为一个成员变量`组合`到结构体中, 成员变量默认访问自己的, 没有就访问 `父类` 的
1. 接口定义在任何地方都没有问题, 始终会被继承, 优先使用本包的接口
1. 对外提供的方法和结构体名称和文件名没有任何关系, 和包名, 结构体名, 函数名有直接关系

> 测试文件

```go
package Demo

import (
	"fmt"
	"testing"

	"Box"
	. "Demo"
)

func TestDemo(t *testing.T) {
	_, _ = fmt.Println(new(Apple).Test())
	_, _ = fmt.Println(new(Bee).Test())
	_, _ = fmt.Println(new(Book).Test())
	_, _ = fmt.Println(new(Book).Demo())
	_, _ = fmt.Println(new(Box.Car).Test())
	_, _ = fmt.Println(new(Box.Cat).Test())

	_, _ = fmt.Println(Bee{Id: 123123}.SetIndex(10).GetIndex())
	_, _ = fmt.Println(new(Bee).GetIndex())
	_, _ = fmt.Println(new(Box.Car).GetIndex())
}
```

> 三个源文件

```go
package Demo

type Thing interface {
	Test() string
}

type Some interface {
	Demo() string
}

type Apple struct {
	Food
	weight float32
}

type Food struct {
	name string
}

func (apple Apple) Test() string {
    return "apple"
}
```

```go
package Demo

var index = 0

type Bee struct {
	Id int
}

func Bee_(id int) *Bee {
	return &Bee{Id: id}
}

func BeeId(id int) *Bee {
	return &Bee{Id: id}
}

func (Bee) Test() string {
	return "bee"
}

func (bee Bee) SetIndex(in int) *Bee {
	index = in
	return &bee
}

func (Bee) GetIndex() int {
	return index
}

type Book struct {
}

func (Book) Test() string {
	return "book"
}

func (Book) Demo() string {
	return "book demo ..."
}
```

```go
package Box

var index = 0

type Car struct {
}

func (Car) Test() string {
	return "car"
}

func (Car) GetIndex() int {
	return index
}

type Cat struct {
}

func (Cat) Test() string {
	return "cat"
}
```
