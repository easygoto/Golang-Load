# 基本语法

## 数据类型

```go
package main

import (
    "fmt"
)

type Model interface {
    getId() int
}

type Admin struct {
    id int
}

func (admin Admin) getId() int {
    return admin.id
}

type User struct {
    id      int
    name    string
    isAdmin bool
}

func (user User) getId() int {
    return user.id
}

func main() {
    var ui uint = 0xffffffffffffffff
    var i, f, c, s, cx = 99999999, 3.099128981278123123, '和', "Welcome", 12 + 3i
    var pui, pf, pcx, ps = &ui, &f, &cx, &s
    fmt.Printf("%-24T: %t\n", false, false)
    fmt.Printf("%-24T: %d, %o, %x, %X\n", i, i, i, i, i)
    fmt.Printf("%-24T: %d, %X\n", ui, ui, ui)
    fmt.Printf("%-24T: %.6f\n", f, f)
    fmt.Printf("%-24T: %f\n", cx, cx)
    fmt.Printf("%-24T: %c(%d)\n", c, c, c)
    fmt.Printf("%-24T: %s\n", s, s)
    fmt.Printf("%-24T: %p = %d\n", pui, pui, *pui)
    fmt.Printf("%-24T: %p = %f\n", pf, pf, *pf)
    fmt.Printf("%-24T: %p = %f\n", pcx, pcx, *pcx)
    fmt.Printf("%-24T: %p = %s\n", ps, ps, *ps)
    fmt.Println()

    arr := [...]User{{11, "root", true}, {12, "test", false}, {21, "user", false}}
    mp := map[string]string{"a": "apple", "b": "banana", "d": "dog"}
    st := struct{ id int }{1}
    user := User{id: 1, name: "admin", isAdmin: true}
    mod := Admin{56}
    ch := make(chan User)
    fn := func(msg string) string { return "msg: " + msg }
    fmt.Printf("%-24T: %v\n", arr, arr)
    fmt.Printf("%-24T: %v\n", mp, mp)
    fmt.Printf("%-24T: %v, len=%d\n", s[1:5], s[1:5], len(s[1:5]))
    fmt.Printf("%-24T: %v, len=%d, cap=%d\n", arr[1:], arr[1:], len(arr[1:]), cap(arr[1:]))
    fmt.Printf("%-24T: %#v\n", st, st)
    fmt.Printf("%-24T: %+v\n", user, user)
    fmt.Printf("%-24T: %+v, id: %d\n", mod, mod, mod.getId())
    fmt.Printf("%-24T: %#v\n", ch, ch)
    fmt.Printf("%-24T: %#v, %s\n", fn, &fn, fn("hello"))
}
```

### Printf

- %v: 自然形式内容
- %+v: 自然形式 json
- %#v: 自然形式 id 和 json
- %T: 类型
- %t: 布尔值
- %b: 二进制
- %o: 八进制
- %d: 十进制整型
- %x: 十六进制
- %X: 大写的十六进制
- %x: base64 编码
- %f: 浮点数, 复数
- %g: 精确浮点数, 复数
- %e: 科学计数法
- %E: 科学计数法
- %c: unicode 字符
- %s: 字符串
- %U: unicode 字符串
- %q: 带有引号
- %p: 指针值

## 特性

- 创建
    - make: 返回引用类型
    - new: 返回指针类型
- 基础方法
    - append: `切片`添加, 扩容
    - copy: `切片`拷贝
    - delete: 删除 map 中元素
    - close: 关闭 chan, 禁止写入
    - len: 实际长度, 支持 string, array, slice, map, chan
    - cap: 容器容量, 支持 array, slice, chan
- 异常处理
    - panic: 中断程序, 抛出信息
    - recover: 接收抛出的信息
    - defer: 关键字, 最后一定要做的事情
- 指针
    - 基本: 不支持指针++, --, 指向指针的指针和 C 语言一致, 没有函数指针
    - 指针数组: 一个数组里全是指针
    - 数组指针: 指向数组的指针
- json
    - Marshal: 序列化, 结构体中只会序列公用的字段, 结构体可以指定字段的映射
    - Unmarshal: 反序列化, 需要传递反序列化的原型
- module
    - `go mod init modname` 初始化模块
    - `go mod graph` 依赖
    - `go mod why` 依赖关系
    - `go list -m all` 列出依赖关系
    - `go get` 获取包
    - `go build` 此时也会添加依赖
    - `go mod download` 下载依赖
    - `go mod tidy` 整理依赖
    - `go mod verify` 验证依赖
    - `go mod edit` 编辑 mod 的属性, help
    - `go mod vendor` 依赖放到 vendor 中

```go
package test

import (
	"encoding/json"
	"fmt"
	"testing"
)

type User struct {
	Id    int     `json:"id"`
	Money float64 `json:"money"`
}

func TestJson(t *testing.T) {
	jsonStr, err := json.Marshal(User{1, 3.14})
	if err != nil {
		panic(err)
	}
	_, _ = fmt.Println(string(jsonStr))

	u1 := User{}
	u2 := new(User)
	err1 := json.Unmarshal(jsonStr, &u1)
	err2 := json.Unmarshal(jsonStr, u2)
	if err1 != nil || err2 != nil {
		panic(err)
	}
	_, _ = fmt.Println(u1, u2)
}

func TestPoint(t *testing.T) {
	var ui uint = 123
	pUi := &ui
	ppUi := &pUi
	_, _ = fmt.Println(ui, &ui, *pUi, pUi, &pUi, **ppUi, *ppUi, ppUi)

	// 数组的指针
	var arr = [...]int{1, 2, 3}
	pArr := &arr
	_, _ = fmt.Println(pArr, (*pArr)[0], (*pArr)[1], (*pArr)[2])

	// 指针的数组
	a, b, c := 1, 2, 3
	pBrr := [...]*int{&a, &b, &c}
	_, _ = fmt.Println(pBrr, *pBrr[0], *pBrr[1], *pBrr[2])
}

func TestBasicFn(t *testing.T) {
	list := make([]string, 2)
	list[0] = "root"
	list[1] = "admin"
	_, _ = fmt.Printf("len=%d,cap=%d,value=%v,addr=%p\n", len(list), cap(list), list, &list)

	list = append(list, "user", "test")
	_, _ = fmt.Printf("len=%d,cap=%d,value=%v,addr=%p\n", len(list), cap(list), list, &list)

	listCp := make([]string, 2)
	copy(listCp, list)
	_, _ = fmt.Printf("len=%d,cap=%d,value=%v,addr=%p\n", len(listCp), cap(listCp), listCp, &listCp)
}

func TestExcept(t *testing.T) {
	defer func() {
		msg := recover()
		_, _ = fmt.Println("======== debug ========:", msg)
	}()
	panic("异常")
}

func TestNew(t *testing.T) {
	user := new(User)
	userCh := new(chan User)
	userMap := new(map[string]*User)

	user.Id = 1
	user.Money = 3.1415926535897932354626

	go func() {
		*userCh <- User{3, 3.1415926}
		*userCh <- User{4, 2.71828}
		close(*userCh)
	}()

	*userMap = map[string]*User{} // 需要初始化
	(*userMap)["root"] = &User{0, 1.7e308}
	(*userMap)["admin"] = &User{11, 3.4e38}
	delete(*userMap, "admin") // 删除元素

	_, _ = fmt.Println(user, userCh, userMap)
}

func TestMake(t *testing.T) {
	userSlice := make([]User, 2)
	userCh := make(chan User)
	userMap := make(map[string]User)

	userSlice[0] = User{1, 0.618}
	//userSlice[2] = User{2, 1.41421} // 数组越界

	go func() {
		userCh <- User{3, 3.1415926}
		userCh <- User{4, 2.71828}
		close(userCh)
	}()

	userMap["root"] = User{0, 1.7e308}
	userMap["admin"] = User{11, 3.4e38}

	_, _ = fmt.Println(userSlice, userCh, userMap)
}
```

## 并发

- go: 启动一个 goroutine, 协程没有运行的原因可能是主程序结束, 协程也跟着结束
- chan: 协程之间的通信, 必须在 goroutine 中执行
    - `func(c chan int) { }` 读写均可的 chan
    - `func(c <-chan int) { }` 只读的 chan
    - `func(c chan<- int) { }` 只写的 chan
    - 作为一个好的习惯, 写完 chan 需要 close
- select: 阻塞式从 chan 读取数据, 自上向下依次读取
- WaitGroup: 协程同步
    - Add(delta): 添加协程记录, delta 表示需要几次 `Done` 才能解除
    - Done(): 移除一个协程记录
    - Wait(): 等待所有协程完成, 若总 delta 不等于总 Done 的数量, 会发生死锁

```go
package test

import (
	"fmt"
	"runtime"
	"sync"
	"testing"
	"time"
)

func TestWaitGroup(t *testing.T) {
	var wg sync.WaitGroup
	go func(wg *sync.WaitGroup) {
		wg.Add(1)
		_, _ = fmt.Println("123123")
	}(&wg)
	go func(wg *sync.WaitGroup) {
		wg.Add(2)
		_, _ = fmt.Println("qwe")
	}(&wg)
	go func() {
		wg.Done()
		_, _ = fmt.Println("done ...")
	}()
	go func() {
		wg.Done()
		_, _ = fmt.Println("done ...")
	}()
	go func() {
		wg.Done()
		_, _ = fmt.Println("done ...")
	}()
	wg.Wait()
	_, _ = fmt.Println("all done ...")
}

func TestGoroutine(t *testing.T) {
	_, _ = fmt.Println(runtime.NumCPU()) // CPU 核心数

	ch1 := make(chan string)
	ch2 := make(chan string)
	ch3 := make(chan string)
	go Send(ch1, ch2, ch3)
	go Receive(ch1, ch2, ch3)

	time.Sleep(time.Millisecond)
}

func Send(ch1, ch2, ch3 chan<- string) {
	for i := 0; i < 10; i++ {
		ch1 <- fmt.Sprintf("channel 1 : %d", i)
		ch2 <- fmt.Sprintf("channel 2 : %d", i)
		ch3 <- fmt.Sprintf("channel 3 : %d", i)
	}
}

func Receive(ch1, ch2, ch3 <-chan string) {
	for {
		select {
		case v := <-ch1:
			_, _ = fmt.Println(v)
		case v := <-ch2:
			_, _ = fmt.Println(v)
		case v := <-ch3:
			_, _ = fmt.Println(v)
		}
	}
}
```

## 面向对象

1. `静态` 文件中函数外部定义的变量, 类似于静态变量
1. `封装` type struct 可以作为类使用 `type Apple struct {}`
1. `多态` type interface 作为接口, 类不需要声明直接实现方法, 实现方法后就是该接口的子类
1. `构造` 构造方法需要对外提供若干函数, 来实现构造函数的功能 `func (apple Apple) NewApple() *Apple {return &Apple{}}`
1. `继承` 可以把要继承的结构体作为一个成员变量`组合`到结构体中, 成员变量默认访问自己的, 没有就访问 `父类` 的
1. 接口定义在任何地方都没有问题, 始终会被继承, 优先使用本包的接口
1. 对外提供的方法和结构体名称和文件名没有任何关系, 和包名, 结构体名, 函数名有直接关系

> 测试文件

```go
package Demo

import (
	"fmt"
	"testing"

	"Box"
	. "Demo"
)

func TestDemo(t *testing.T) {
	_, _ = fmt.Println(new(Apple).Test())
	_, _ = fmt.Println(new(Bee).Test())
	_, _ = fmt.Println(new(Book).Test())
	_, _ = fmt.Println(new(Book).Demo())
	_, _ = fmt.Println(new(Box.Car).Test())
	_, _ = fmt.Println(new(Box.Cat).Test())

	_, _ = fmt.Println(Bee{Id: 123123}.SetIndex(10).GetIndex())
	_, _ = fmt.Println(new(Bee).GetIndex())
	_, _ = fmt.Println(new(Box.Car).GetIndex())
}
```

> 三个源文件

```go
package Demo

type Thing interface {
	Test() string
}

type Some interface {
	Demo() string
}

type Apple struct {
	Food
	weight float32
}

type Food struct {
	name string
}

func (apple Apple) Test() string {
    return "apple"
}
```

```go
package Demo

var index = 0

type Bee struct {
	Id int
}

func Bee_(id int) *Bee {
	return &Bee{Id: id}
}

func BeeId(id int) *Bee {
	return &Bee{Id: id}
}

func (Bee) Test() string {
	return "bee"
}

func (bee Bee) SetIndex(in int) *Bee {
	index = in
	return &bee
}

func (Bee) GetIndex() int {
	return index
}

type Book struct {
}

func (Book) Test() string {
	return "book"
}

func (Book) Demo() string {
	return "book demo ..."
}
```

```go
package Box

var index = 0

type Car struct {
}

func (Car) Test() string {
	return "car"
}

func (Car) GetIndex() int {
	return index
}

type Cat struct {
}

func (Cat) Test() string {
	return "cat"
}
```

## 网络编程

```go
package test

import (
	"fmt"
	"net/http"
	"testing"
)

func TestHttpServer(t *testing.T) {
	http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
		_, _ = fmt.Fprintf(writer, "<h1>Welcome! %s!</h1>", request.FormValue("name"))
	})
	_ = http.ListenAndServe(":8888", nil)
}
```
